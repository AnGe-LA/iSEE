#' @importFrom shiny observe updateSelectizeInput
.define_table_selection_observer <- function(panel_name, input, session, pObjects, rObjects) {
    # No need for underscore in 'select_field' definition, as this is already in the '.int' constant.
    select_field <- paste0(panel_name, .int_statTableSelected)

    # Updating memory for new selection parameters 
    observe({
        chosen <- input[[select_field]]
        if (length(chosen)==0L) {
            return(NULL)
        }

        chosen <- rownames(pObjects$coordinates[[panel_name]])[chosen]
        previous <- pObjects$memory[[panel_name]][[.TableSelected]] 
        if (chosen==previous) {
            return(NULL)
        }
        pObjects$memory[[panel_name]][[.TableSelected]] <- chosen

        .safe_reactive_bump(rObjects, paste0(panel_name, "_", .propagateDimnames))
    })
}

#' @importFrom shiny eventReactive updateSelectizeInput
.define_dimname_propagation_observer <-  function(panel_name, choices, session, pObjects, rObjects) {
    dimname_field <- paste0(panel_name, "_", .propagateDimnames)
    .safe_reactive_init(rObjects, dimname_field)

    observeEvent(rObjects[[dimname_field]], {
        instance <- pObjects$memory[[panel_name]]

        if (is(instance, "DotPlot")) {
            chosen <- .get_n_selected_points(pObjects$coordinates[[panel_name]], 
                instance[[.brushData]], count=FALSE)
            if (!length(chosen)) {
                return(NULL)
            }
            chosen <- chosen[1]
        } else if (is(instance, "Table")) {
            chosen <- instance[[.TableSelected]]
        }  else {
            return(NULL)
        }

        dependents <- .get_direct_children(pObjects$aesthetics_links, panel_name, names_only=FALSE)
        for (kid in names(dependents)) {
            all_fields <- dependents[[kid]]

            # There is a possibility that this would cause multi-rendering as they
            # trigger different observers. Oh well.
            for (field in all_fields) {
                updateSelectizeInput(session, paste0(kid, "_", field), server=TRUE, 
                    choices=choices, selected=chosen)
            }
        }
    })
}

#' Set up a table observer
#'
#' Set up the actions for an observer for a parameter choice in a plot panel that may involve a linked table.
#'
#' @param mode String specifying the encoded panel type of the current (receiving) plot.
#' @param id Integer scalar specifying the index of the current panel of the specified type.
#' @param pObjects An environment containing \code{table_links}, a graph produced by \code{\link{.spawn_table_links}};
#' and \code{memory}, a list of DataFrames containing parameters for each panel of each type.
#' @param rObjects A reactive list containing incrementable counters for all panels,
#' @param input A Shiny list of inputs, generated by the server.
#' @param session A \code{session} object from a Shiny server.
#' @param by_field String specifying the name of the field containing the data source for the current panel.
#' @param title String specifying the title used for table-based data sources, to match to the value of \code{by_field} in \code{memory} for this plot.
#' @param select_field String specifying the name of the field containing the selected row for this panel.
#' @param tab_field String specifying the name of the field containing the decoded name of the table input for this panel.
#' @param select_choices Vector of consecutive integers indexing all rows, named with the row names.
#' @param param String specifying the type of table link to the current plot, i.e., color or x/y-axis.
#'
#' @return A logical scalar indicating whether the current (receiving) plot needs to be regenerated.
#'
#' @details
#' This function has a number of side-effects, relying on the pass-by-reference behaviour of \code{pObjects}, \code{rObjects} and \code{session} to perform its role.
#' \itemize{
#' \item New values of the fields \code{by_field} and \code{tab_field} in \code{input} overwrite values in \code{pObjects$memory} for the current panel.
#' \item \code{pObjects$table_links} is modified for the new linked table in \code{input[[tab_field]]}.
#' Note that table links are \emph{not} destroyed if \code{input[[by_field]]} is different to \code{title},
#' as this could result in failure to clear the memory of the current panel in \code{\link{.delete_table_links}}.
#' \item Link panel counters in \code{rObjects} are incremented if the new linked table differs from the old link table and \code{input[[by_field]]==title};
#' or if \code{input[[by_field]]} differs from that in memory and either of them is equal to \code{title}.
#' Counters are only updated for the current panel as well as the old/new tables, and only when
#' \item The selectize UI element corresponding to \code{select_field} is updated with the current selection in the linked table, if a new linked table was chosen.
#' Note that this will trigger another call to the observer that contains this function.
#' }
#'
#' The flag to regenerate the current plot is set if the \code{by_field} and \code{tab_field} fields in \code{input} are non-\code{NULL};
#' and the \code{by_field} entry differs from the parameter currently stored in memory.
#'
#' Note that \code{by_field} and \code{title} are ignored if \code{param="yaxis"}, as the y-axis of feature/sample assay plots have no other choice of variable.
#'
#' @author Aaron Lun
#' @rdname INTERNAL_setup_table_observer
#' @seealso
#' \code{\link{.modify_table_links}},
#' \code{\link{iSEE}}
#'
#' @importFrom shiny updateSelectizeInput
#' @importFrom methods as
.setup_table_observer <- function(plot_name, by_field, title, select_field, tab_field, choices, 
    input, session, pObjects, rObjects) 
{
    .input_FUN <- function(field) paste0(plot_name, "_", field)
    uses_by_field <- !is.na(by_field)

    # Checking that all the incoming arguments are non-NULL.
    if (uses_by_field) {
        choice <- input[[.input_FUN(by_field)]]
    } else {
        choice <- title <- ""
    }
    tab <- input[[.input_FUN(tab_field)]]
    if (is.null(choice) || is.null(tab)) {
        return(FALSE)
    }

    # Obtaining the old parameter choices, enforcing type and updating memory.
    # The new values should persist due to environment's pass-by-reference.
    if (uses_by_field) {
        old_choice <- pObjects$memory[[plot_name]][[by_field]]
        choice <- as(choice, typeof(old_choice))
        pObjects$memory[[plot_name]][[by_field]] <- choice
    } else {
        old_choice <- choice
    }

    old_tab <- pObjects$memory[[plot_name]][[tab_field]]
    tab <- as(tab, typeof(old_tab))
    pObjects$memory[[plot_name]][[tab_field]] <- tab

    if (old_tab!=tab) {
        # Editing the aesthetics_links, if we're switching the aesthetics choice.
        pObjects$aesthetics_links <- .choose_new_parent(pObjects$aesthetics_links, 
            plot_name, tab, old_tab, field=select_field)

        # Updating the selection, based on the currently selected row.
        if (tab!=.noSelection) {
            new_selected <- old_selected <- pObjects$memory[[plot_name]][[select_field]]

            parent <- pObjects$memory[[tab]]
            if (is(parent, "Table")) {
                new_selected <- parent[[.TableSelected]]
            } else if (is(parent, "DotPlot")) {
                chosen <- .get_n_selected_points(pObjects$coordinates[[tab]], 
                    parent[[.brushData]], count=FALSE)
                if (length(chosen)) {
                    new_selected <- chosen[1]
                }
            }

            # We use session=NULL only for unit testing the rest of the function.
            if (new_selected != old_selected && !is.null(session)) { 
                all_choices <- rownames(pObjects$coordinates[[tab]])
                updateSelectizeInput(session, .input_FUN(select_field), label = NULL, 
                    choices = choices, server = TRUE, selected = new_selected) # nocov
            }
        }
    }

    # Updating the link UI elements, but only if there was a change to table identities or linking.
    if ((choice==title)!=(old_choice==title) || (choice==title && tab!=old_tab)) {
        tab_names <- setdiff(union(old_tab, tab), .noSelection)
        for (relinked in c(plot_name, tab_names)) {
            .safe_reactive_bump(rObjects, paste0(relinked, "_", .panelLinkInfo))
        }
    }

    # Not replotting if the row choice has not changed. Note that the identical-ness of 'tab'
    # doesn't matter here, as the row name determines the plot.
    !identical(old_choice, choice)
}
