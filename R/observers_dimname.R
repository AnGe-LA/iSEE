#' @importFrom shiny eventReactive updateSelectizeInput
.define_dimname_propagation_observer <-  function(panel_name, choices, session, pObjects, rObjects) {
    dimname_field <- paste0(panel_name, "_", .propagateDimnames)
    .safe_reactive_init(rObjects, dimname_field)

    observeEvent(rObjects[[dimname_field]], {
        instance <- pObjects$memory[[panel_name]]

        if (is(instance, "DotPlot")) {
            chosen <- .get_brushed_points(pObjects$coordinates[[panel_name]], instance[[.brushData]])
            if (!length(chosen)) {
                return(NULL)
            }
            chosen <- chosen[1]
        } else if (is(instance, "Table")) {
            chosen <- instance[[.TableSelected]]
        }  else {
            return(NULL)
        }

        dependents <- .get_direct_children(pObjects$aesthetics_links, panel_name)
        for (kid in names(dependents)) {
            all_fields <- dependents[[kid]]

            # There is a possibility that this would cause multi-rendering as they
            # trigger different observers. Oh well.
            for (field in all_fields) {
                updateSelectizeInput(session, paste0(kid, "_", field), server=TRUE, 
                    choices=choices, selected=chosen)
            }
        }
    })
}

#' Set up a dimname choice observer
#'
#' Set up the actions for an observer for a parameter choice in a plot panel that may involve a linked table.
#'
#' @param mode String specifying the encoded panel type of the current (receiving) plot.
#' @param id Integer scalar specifying the index of the current panel of the specified type.
#' @param pObjects An environment containing \code{table_links}, a graph produced by \code{\link{.spawn_table_links}};
#' and \code{memory}, a list of DataFrames containing parameters for each panel of each type.
#' @param rObjects A reactive list containing incrementable counters for all panels,
#' @param input A Shiny list of inputs, generated by the server.
#' @param session A \code{session} object from a Shiny server.
#' @param by_field String specifying the name of the field containing the data source for the current panel.
#' @param title String specifying the title used for table-based data sources, to match to the value of \code{by_field} in \code{memory} for this plot.
#' @param select_field String specifying the name of the field containing the selected row for this panel.
#' @param tab_field String specifying the name of the field containing the decoded name of the table input for this panel.
#' @param select_choices Vector of consecutive integers indexing all rows, named with the row names.
#' @param param String specifying the type of table link to the current plot, i.e., color or x/y-axis.
#'
#' @return A logical scalar indicating whether the current (receiving) plot needs to be regenerated.
#'
#' @details
#' This function has a number of side-effects, relying on the pass-by-reference behaviour of \code{pObjects}, \code{rObjects} and \code{session} to perform its role.
#' \itemize{
#' \item New values of the fields \code{by_field} and \code{tab_field} in \code{input} overwrite values in \code{pObjects$memory} for the current panel.
#' \item \code{pObjects$table_links} is modified for the new linked table in \code{input[[tab_field]]}.
#' Note that table links are \emph{not} destroyed if \code{input[[by_field]]} is different to \code{title},
#' as this could result in failure to clear the memory of the current panel in \code{\link{.delete_table_links}}.
#' \item Link panel counters in \code{rObjects} are incremented if the new linked table differs from the old link table and \code{input[[by_field]]==title};
#' or if \code{input[[by_field]]} differs from that in memory and either of them is equal to \code{title}.
#' Counters are only updated for the current panel as well as the old/new tables, and only when
#' \item The selectize UI element corresponding to \code{select_field} is updated with the current selection in the linked table, if a new linked table was chosen.
#' Note that this will trigger another call to the observer that contains this function.
#' }
#'
#' The flag to regenerate the current plot is set if the \code{by_field} and \code{tab_field} fields in \code{input} are non-\code{NULL};
#' and the \code{by_field} entry differs from the parameter currently stored in memory.
#'
#' Note that \code{by_field} and \code{title} are ignored if \code{param="yaxis"}, as the y-axis of feature/sample assay plots have no other choice of variable.
#'
#' @author Aaron Lun
#' @rdname INTERNAL_setup_dimname_source_observer
#' @seealso
#' \code{\link{.modify_table_links}},
#' \code{\link{iSEE}}
#'
#' @importFrom shiny updateSelectizeInput
#' @importFrom methods as
.setup_dimname_source_observer <- function(plot_name, by_field, title, select_field, tab_field, choices, 
    input, session, pObjects, rObjects) 
{
    .input_FUN <- function(field) paste0(plot_name, "_", field)
    uses_by_field <- !is.na(by_field)

    # Checking that all the incoming arguments are non-NULL.
    if (uses_by_field) {
        choice <- input[[.input_FUN(by_field)]]
    } else {
        choice <- title <- ""
    }
    tab <- input[[.input_FUN(tab_field)]]
    if (is.null(choice) || is.null(tab)) {
        return(FALSE)
    }

    # Obtaining the old parameter choices, enforcing type and updating memory.
    # The new values should persist due to environment's pass-by-reference.
    if (uses_by_field) {
        old_choice <- pObjects$memory[[plot_name]][[by_field]]
        choice <- as(choice, typeof(old_choice))
        pObjects$memory[[plot_name]][[by_field]] <- choice
    } else {
        old_choice <- choice
    }

    old_tab <- pObjects$memory[[plot_name]][[tab_field]]
    tab <- as(tab, typeof(old_tab))
    pObjects$memory[[plot_name]][[tab_field]] <- tab

    if (old_tab!=tab) {
        # Editing the aesthetics_links, if we're switching the aesthetics choice.
        pObjects$aesthetics_links <- .choose_new_parent(pObjects$aesthetics_links, 
            plot_name, tab, old_tab, field=select_field)

        # Updating the selection, based on the currently selected row.
        if (tab!=.noSelection) {
            new_selected <- old_selected <- pObjects$memory[[plot_name]][[select_field]]

            parent <- pObjects$memory[[tab]]
            if (is(parent, "Table")) {
                new_selected <- parent[[.TableSelected]]
            } else if (is(parent, "DotPlot")) {
                chosen <- .get_brushed_points(pObjects$coordinates[[tab]], parent[[.brushData]])
                if (length(chosen)) {
                    new_selected <- chosen[1]
                }
            }

            # We use session=NULL only for unit testing the rest of the function.
            if (new_selected != old_selected && !is.null(session)) { 
                all_choices <- rownames(pObjects$coordinates[[tab]])
                updateSelectizeInput(session, .input_FUN(select_field), label = NULL, 
                    choices = choices, server = TRUE, selected = new_selected) # nocov
            }
        }
    }

    # Updating the link UI elements, but only if there was a change to table identities or linking.
    if ((choice==title)!=(old_choice==title) || (choice==title && tab!=old_tab)) {
        tab_names <- setdiff(union(old_tab, tab), .noSelection)
        for (relinked in c(plot_name, tab_names)) {
            .safe_reactive_bump(rObjects, paste0(relinked, "_", .panelLinkInfo))
        }
    }

    # Not replotting if the row choice has not changed. Note that the identical-ness of 'tab'
    # doesn't matter here, as the row name determines the plot.
    !identical(old_choice, choice)
}


#' Define dimension name observer
#'
#' Define an observer to track changes to fields involving the dimension name.
#'
#' @inheritParams .define_plot_parameter_observers
#' @param name_field String specifying the name of the parameter that uses the dimension name as input.
#' @param choices Character vector containing the all possible (unique) choices for the dimension name.
#' @param in_use_field String specifying the parameter field of \code{pObjects$memory} that indicates whether the panel is currently responsive to the dimension name for its plot.
#' If \code{NA}, the panel is assumed to always respond on the dimension name.
#' @param in_use_value String specifying the value of the parameter field that indicates whether the panel is currently responding  to the dimension name for its plot.
#' @param is_protected Logical scalar indicating if the dimension name is a protected parameter (see \code{\link{.define_plot_parameter_observers}}.
#' @param table_field String specifying the parameter field of \code{pObjects$memory} that specifies the transmitting table panel for a selection of the dimension name.
#' @param link_type String specifying the link type for the current parameter to the transmitting table in \code{table_field}, same as \code{param=} in \code{\link{.setup_dimname_source_observer}}.
#'
#' @return
#' An observer is set up to track changes to the dimension name, possibly triggering a regeneration of the plot.
#' Another observer is set up to detect changes in the transmitting panels.
#'
#' @details
#' This is handled separately from the other observers because:
#' \itemize{
#' \item The \code{\link{selectizeInput}} element used for the dimension names are typically updated server-side,
#' requiring some care to defend against empty inputs before the \code{\link{updateSelectizeInput}} runs.
#' \item The dimension name can change (due to the linked table) without directly affecting the plot,
#' if the dimension name is not currently in use.
#' In such cases, we want to avoid needless re-rendering.
#' }
#'
#' @author Aaron Lun
#'
#' @rdname INTERNAL_define_dim_name_observer
#' @importFrom shiny observeEvent observe updateSelectizeInput
.define_dimname_observers <- function(plot_name, name_field, choices,
    in_use_field, in_use_value, is_protected, table_field, 
    input, session, pObjects, rObjects)
{
    name_input <- paste0(plot_name, "_", name_field)
    always_in_use <- is.na(in_use_field)

    observeEvent(input[[name_input]], {
        # Required to defend against empty strings before updateSelectizeInput runs upon re-render.
        req(input[[name_input]])

        matched_input <- as(input[[name_input]], typeof(pObjects$memory[[plot_name]][[name_field]]))
        if (identical(matched_input, pObjects$memory[[plot_name]][[name_field]])) {
            return(NULL)
        }
        pObjects$memory[[plot_name]][[name_field]] <- matched_input

        # Only regenerating if the current parameter is actually in use.
        if (always_in_use || pObjects$memory[[plot_name]][[in_use_field]]==in_use_value) {
            if (!is_protected) {
                .safe_reactive_bump(rObjects, plot_name)
            } else {
                .regenerate_unselected_plot(plot_name, pObjects, rObjects)
            }
        }
    }, ignoreInit=TRUE)

    # Observer for the linked panel that controls the dimname selection.
    observe({
        replot <- .setup_dimname_source_observer(plot_name,
            by_field=in_use_field, title=in_use_value,
            select_field=name_field, tab_field=table_field,
            choices=choices,
            input=input, session=session,
            pObjects=pObjects, rObjects=rObjects)

        if (replot) {
            if (!is_protected) {
                .safe_reactive_bump(rObjects, plot_name)
            } else {
                .regenerate_unselected_plot(plot_name, pObjects, rObjects)
            }
        }
    })

    observe({
        force(rObjects$rerendered)

        # Protect against re-rendering after deleting a panel.
        if (plot_name %in% names(pObjects$memory)) {
            updateSelectizeInput(session, paste0(plot_name, "_", name_field),
                choices=choices, selected=pObjects$memory[[plot_name]][[name_field]], server=TRUE)
        }
    })

    invisible(NULL)
}
